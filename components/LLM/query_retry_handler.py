# D:\Projects\NextMove\components\LLM\query_retry_handler.py

import json
from langchain_core.prompts import ChatPromptTemplate
from ..LLM.llm_loader import load_llm
from constants import *
from entities.config import GLOBAL_SCHEMA

# Load current LLM dynamically
llm = load_llm(CURRENT_LLM)


def parse_llm_json_response(llm_response: str) -> dict:
    """
    Parses an LLM response that returns JSON wrapped in triple backticks (```json ... ```).

    Args:
        llm_response (str): Raw response from LLM.

    Returns:
        dict: Parsed JSON.

    Raises:
        ValueError: If JSON parsing fails.
    """
    raw_content = llm_response.content.strip() if hasattr(llm_response, 'content') else llm_response.strip()

    # Remove surrounding triple backticks if present
    if raw_content.startswith("```") and raw_content.endswith("```"):
        lines = raw_content.splitlines()
        if lines[0].startswith("```"):
            lines = lines[1:]
        if lines and lines[-1].startswith("```"):
            lines = lines[:-1]
        raw_content = "\n".join(lines).strip()

    try:
        result_json = json.loads(raw_content)
    except json.JSONDecodeError as e:
        raise ValueError(
            f"Failed to parse JSON from LLM response: {e}\nRaw content:\n{raw_content}"
        )
    return result_json


class QueryRetryHandler:
    """
    Handles retries for invalid SQL queries generated by:
    1. LLM global query generation.
    2. Source-specific translation.
    """

    def __init__(self, max_retries: int = 3):
        self.max_retries = max_retries

    def retry_global_sql(self, natural_query: str, previous_sql: str, validation_errors: list):
        """
        Retry generating a valid global SQL query using LLM.

        Args:
            natural_query (str): Original user query.
            previous_sql (str): Previous SQL generated by LLM.
            validation_errors (list): Errors from SQL validator.

        Returns:
            str: Corrected valid SQL query.
        """
        prompt_template = ChatPromptTemplate.from_messages([
            ("system", QUERY_ANALYZER_RETRY_SYSTEM_PROMPT),
            ("human", "{user_query}")
        ])

        for attempt in range(self.max_retries):
            prompt = prompt_template.invoke({
                "natural_query": natural_query,
                "global_schema": ", ".join(GLOBAL_SCHEMA.keys()),
                "previous_sql": previous_sql,
                "validation_errors": "\n".join(validation_errors)
            })

            response = llm(prompt.messages)
            result = parse_llm_json_response(response)

            corrected_sql = result.get("corrected_sql")
            if corrected_sql:
                return corrected_sql
        raise RuntimeError(f"Failed to get valid global SQL after {self.max_retries} retries.")

    def retry_translation(self, global_sql: str, source_name: str, db_type: str,
                          previous_translation: str, local_schema: dict, validation_errors: list):
        """
        Retry translating a global SQL query to a valid source-specific SQL query.

        Args:
            global_sql (str): The valid global SQL query.
            source_name (str): Source being translated to.
            db_type (str): DB type of the source (mysql/postgres).
            previous_translation (str): Previous translation attempt.
            local_schema (dict): Source-specific schema (column -> type).
            validation_errors (list): Errors from SQL validator.

        Returns:
            str: Corrected source-specific SQL query.
        """
        prompt_template = ChatPromptTemplate.from_messages([
            ("system", QUERY_TRANSLATE_RETRY_SYSTEM_PROMPT),
            ("human", "{user_query}")
        ])

        for attempt in range(self.max_retries):
            prompt = prompt_template.invoke({
                "global_sql": global_sql,
                "source_name": source_name,
                "db_type": db_type,
                "previous_translation": previous_translation,
                "global_schema": ", ".join(GLOBAL_SCHEMA.keys()),
                "local_schema": json.dumps(local_schema, indent=2),
                "validation_errors": "\n".join(validation_errors)
            })

            response = llm(prompt.messages)
            result = parse_llm_json_response(response)

            corrected_sql = result.get("corrected_sql")
            if corrected_sql:
                return corrected_sql

        raise RuntimeError(f"Failed to get valid translated SQL after {self.max_retries} retries.")
