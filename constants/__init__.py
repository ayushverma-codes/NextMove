# LLM

LLM1 = "gemini"
LLM2 = "ollama"

CURRENT_LLM = LLM1

# Prompts

DEFAULT_LIMIT = 10

QUERY_ANALYZER_SYSTEM_PROMPT = """
You are a Query Analyzer for a federated job information system.

You receive a natural language query about jobs. Some information may exist in the structured databases (CSV sources) and some may require general knowledge (unstructured, LLM).

1. Identify which parts of the query can be answered using the structured databases.
2. Identify which parts require general knowledge (unstructured source).
3. Identify the user's **intent** in plain text (what kind of jobs they are looking for).
4. Identify **how many job listings** the user wants to fetch. If not specified, use {DEFAULT_LIMIT}.
5. For the structured part:
   - Generate the SELECT and WHERE components strictly based on the GLOBAL_SCHEMA attributes.
   - Generate a full SQL query string in **standard SQL** syntax using the Global Schema. Use `LIMIT` for number of rows.


Return a JSON with four keys:
   - user_intent: string describing what the user wants
   - limit: integer number of rows requested
   - structured_query: {{
         "select_clause": [list of attributes from GLOBAL_SCHEMA to retrieve],
         "where_clause": {{attribute: value}}
     }}
   - sql_query: Full SQL query string in Global Schema
   - unstructured_query: text that needs to be answered by the LLM

Global schema attributes: {schema}

Example:
Input: "Find remote Marketing Coordinator jobs in Princeton, NJ with a minimum salary of $17 that require skills like communication, Excel, SQL, and project management. Also, list the company benefits and explain what a 'Marketing Coordinator' typically does. Show 5 results."
Output:
{{
  "user_intent": "Find remote Marketing Coordinator jobs with required skills and salary in Princeton, NJ",
  "limit": 5,
  "structured_query": {{
      "select_clause": ["title", "company_name", "location", "skills", "salary_range", "work_type"],
      "where_clause": {{
          "title": "Marketing Coordinator",
          "location": "Princeton, NJ",
          "work_type": "remote",
          "skills": ["communication", "Excel", "SQL", "project management"],
          "salary_range": ">= 17"
      }}
  }},
  "sql_query": "SELECT title, company_name, location, skills, salary_range, work_type FROM Global_Job_Postings WHERE title='Marketing Coordinator' AND location='Princeton, NJ' AND work_type='remote' AND skills LIKE '%communication%' AND skills LIKE '%Excel%' AND skills LIKE '%SQL%' AND skills LIKE '%project management%' AND salary_range >= 17 LIMIT 5;",
  "unstructured_query": "List company benefits and explain typical responsibilities of a 'Marketing Coordinator'."
}}
"""


QUERY_ANALYZER_HUMAN_PROMPT = """Input: {user_query}
Output:"""


# Query Retry

QUERY_ANALYZER_RETRY_SYSTEM_PROMPT = """
You are a Query Analyzer for a federated job system. The SQL query generated from the user's natural language input is invalid.

User's natural query:
{natural_query}

Global Schema:
{global_schema}

Previous SQL generated by LLM:
{previous_sql}

Validation errors returned by the SQL validator:
{validation_errors}

Your task:
1. Correct the SQL query so that it is valid against the Global Schema.
2. Keep the intended semantics of the user's query intact.
3. Use standard SQL syntax.
4. Limit results if necessary (use DEFAULT_LIMIT if no explicit limit provided).

Return JSON with key:
{{
    "corrected_sql": "<valid SQL query>"
}}
"""

QUERY_TRANSLATE_RETRY_SYSTEM_PROMPT = """
You are a SQL Translator for a federated job system.

Global SQL query:
{global_sql}

Previous translation for source "{source_name}" (db_type={db_type}) is invalid:
{previous_translation}

Global Schema:
{global_schema}

Local source schema (columns and types):
{local_schema}

Validation errors returned by the SQL validator:
{validation_errors}

Your task:
1. Translate the global SQL query correctly to the target source schema.
2. Ensure all column names and table names exist in the local schema.
3. Maintain the original query semantics.
4. Use proper SQL syntax for the database type ({db_type}).
5. Include LIMIT if required.

Return JSON with key:
{{
    "corrected_sql": "<valid source-specific SQL query>"
}}
"""


# Query Analyzer and Decomposer

QUERY_INPUT_FILE_PATH = r"D:\Projects\NextMove\workspace_folder\input\natural_queries.txt"  # Path to the input file with natural language queries
QUERY_ANALYZE_OUTPUT_FILE_PATH = r"D:\Projects\NextMove\workspace_folder\artifacts\query_analysis.jsonl"

QUERY_DECOMPOSE_OUTPUT_FILE_PATH = r"D:\Projects\NextMove\workspace_folder\artifacts\query_decompose.jsonl"

